mutate(years =
case_when(
year >= 1800 & year < 1900 ~'1800s',
year >= 1900 & year < 2000 ~'1900s',
year >= 2000 & year < 2100 ~'2000s')) %>%
group_by(sex, years) %>%
summarise(n=sum(n), .groups= 'drop') %>%
ggplot(aes(x = years, y=n, fill =sex)) +
geom_bar(stat = "identity", position ="dodge")
# (1-7, 5 pts) Create a bar plot which compares the number of female and male babies in the 1800s, 1900s, and 2000s. Using chain operations, generate a “one-shot” operation R code.
library(ggplot2)
babynames %>%
mutate(years =
case_when(
year >= 1800 & year < 1900 ~'1800s',
year >= 1900 & year < 2000 ~'1900s',
year >= 2000 & year < 2100 ~'2000s')) %>%
group_by(sex, years) %>%
summarise(n=sum(n), .groups= 'drop') %>%
ggplot(aes(x = years, y=n, fill =sex)) +
geom_bar(stat = "identity", position ="dodge")
babynames %>%
mutate(years =
case_when(
year >= 1800 & year < 1900 ~'1800s',
year >= 1900 & year < 2000 ~'1900s',
year >= 2000 & year < 2100 ~'2000s')) %>%
group_by(sex, years) %>%
summarise(n=sum(n), .groups= 'drop') %>%
ggplot(aes(x = years, y=n, fill =sex)) +
geom_bar(stat = "identity", position ="dodge")
babynames
babynames %>%
groupby(year) %>%
filter(name=="John")
babynames %>%
group_by(year) %>%
filter(name=="John")
babynames %>%
group_by(sex,year) %>%
filter(name=="John")
babynames %>%
group_by(year) %>%
filter(name=="John" & sex=="M")
babynames %>%
group_by(year) %>%
filter((name=="John" | name=="Jacob") & sex=="M")
babynames %>%
group_by(year) %>%
filter((name=="John" | name=="Jacob") & sex=="M") %>%
ggplot(aes(x=year, y=n, fill = name)) %>%
geom_line(stat = "identity")
babynames %>%
group_by(year) %>%
filter((name=="John" | name=="Jacob") & sex=="M") %>%
ggplot(aes(x=year, y=n, fill = name)) +
geom_line(stat = "identity")
babynames %>%
group_by(year) %>%
filter((name=="John" | name=="Jacob") & sex=="M") %>%
ggplot(aes(x=year, y=n, fill = name)) +
geom_line(stat = "identity",position ="dodge")
babynames %>%
group_by(year) %>%
filter((name=="John" | name=="Jacob") & sex=="M") %>%
ggplot(aes(x=year, y=n)) +
geom_line(stat = "identity")
babynames %>%
group_by(year) %>%
filter((name=="John" | name=="Jacob") & sex=="M") %>%
ggplot(aes(x=year, y=n, fill = name)) +
geom_line()+
scale_color_manual(values = c("John" = "lightblue", "Jacob" = "red"))
babynames %>%
group_by(year) %>%
filter((name=="John" | name=="Jacob") & sex=="M") %>%
ggplot(aes(x=year, y=n, color = name)) +
geom_line()+
scale_color_manual(values = c("John" = "lightblue", "Jacob" = "red"))
babynames %>%
group_by(year) %>%
filter((name=="John" | name=="Jacob") & sex=="M") %>%
ggplot(aes(x=year, y=n, color = name)) +
geom_line()
babynames %>%
group_by(year) %>%
filter((name=="John" | name=="Jacob") & sex=="M") %>%
ggplot(aes(x=year, y=n, color = name)) +
geom_line()
babynames %>%
group_by(year) %>%
filter((name=="John" | name=="Jacob" | name=="Kevin") & sex=="M") %>%
ggplot(aes(x=year, y=n, color = name)) +
geom_line()
babynames %>%
group_by(year) %>%
filter((name=="John" | name=="Jacob" | name=="Kevin"|name=="James") & sex=="M") %>%
ggplot(aes(x=year, y=n, color = name)) +
geom_line()
setwd("~/Documents/Handong/2024-2/TextMining/TextMining_R/assignment1")
#### uber ####
path = ~/Documents/Handong/2024-2/TextMining/TextMining_R/assignment1/uber_records/
#### uber ####
path = "~/Documents/Handong/2024-2/TextMining/TextMining_R/assignment1/uber_records/"
file_list = list.files(path=path,full.names=TRUE )
file_list
uber.set <- lapply(file_list, read.csv)
uber.set
uber.set <- lapply(file_list, read.csv) %>% bind_rows()
uber.set %>% head
uber.set %>% filter(Date.Time == '0')
uber.set %>% filter(Date.Time == 0)
uber.set %>% filter(Date.Time == "00:00:00")
uber.set %>% filter(Date.Time == 0)
uber.set %>% filter(Date.Time == 0:00:00)
uber.set %>% filter(Date.Time == "0:00:00")
uber.set <- lapply(file_list, read.csv) %>%
#Combine rows into one data function
bind_rows()
uber.set <- lapply(file_list, read.csv) %>%
#Combine rows into one data function
bind_rows() %>%
#Filter out only the data value that is not equal to zero
filter(Date.Time != 0)
uber.set %>% filter(Date.Time == NULL)
uber.set %>% filter(Date.Time == NULL)
uber.set %>% filter(Date.Time == NaN)
uber.set %>% filter(Date.Time == 00)
typeof(uber.set$Date.Time)
uber.set
library(lubridate)
mdy_hms(uber.set$Date.Time)
uber.set
uber.set <- uber.set %>%
mutate(Date.Time = mdy_hms(Date.Time))
uber.set
uber.set <- uber.set %>%
mutate( #Used mutate to create a new variables to converts a data type
Date = as.Date(Date.Time), #extract only the date and not a time
Time = format(Date.Time, "%MM %SS"),  # Format time as '0M 0S'
year = year(Date.Time), # extract only the year
month = format(Date.Time, "%b"),  # The format "%b" returns the month in abbreviated form
day = day(Date.Time), #extract only the day
dayday = wday(Date.Time, label = TRUE),  # Day of the week as a label (e.g., "Mon")
#label = TRUE ensures the day is shown as a name rather than a number.
hour = hour(Date.Time),  #extract only the hour
minute = minute(Date.Time), #extract only the minute
second = second(Date.Time) #extract only the second
)
uber.set
uber.set %>% head
uber.set %>%
group_by(hour) %>%
summarize(n=n())
uber.set %>%
group_by(hour) %>%
summarize(n=n()) %>%
ggplot(aes(x = hour, y=n)) +
geom_bar()
uber.set %>%
group_by(hour) %>%
summarize(n=n(), .groups = 'drop') %>%
ggplot(aes(x = hour, y=n)) +
geom_bar()
uber.set %>%
group_by(hour) %>%
summarize(n=n(), .groups = 'drop') %>%
ggplot(aes(x = hour, y=n)) +
geom_bar(stat = "identity")
#Draw a bar graph using uber.set
ggplot(uber.set, aes(x = hour)) +
#Fill the bar with skyblue color
geom_bar(fill = "skyblue") +
#label the title as written below
labs(title = "Uber Rides by Hour of the Day",
x = "Hour of the Day",
y = "Number of Rides")
#Draw bar graph setting x-axis equal to dayday
ggplot(uber.set, aes(x = dayday)) +
#Fill the bar with lightgreen
geom_bar(fill = "lightgreen") +
#Lable the title as shown below
labs(title = "Uber Rides by Day of the Week",
x = "Day of the Week",
y = "Number of Rides")
#Create the variable uber_grouped
uber_grouped <- uber.set %>%
#Use group_by to grouped dayday and month variable
group_by(dayday, month) %>%
#Count the number of uber rides
summarise(count = n(),.groups= 'drop' ) %>%
#Inform that any subsequent operations will not be done within this group
ungroup()
uber_grouped
# Plot grouped data using a bar plot. Use x for month value, y for count and fill with dayday value
ggplot(uber_grouped, aes(x = month, y = count, fill = dayday)) +
#Set stat equal to identity, to use actual data value in n_babies.
#Set position to dodge, to separate the each sex for easier comparison
geom_bar(stat = "identity", position = "dodge") +
#Label the title as written below
labs(title = "Uber Rides by Day of the Week and Month",
x = "Day of the Week",
y = "Number of Rides")
uber.set
uber.set %>%
group_by(Lat, Lon) %>%
summarise(n=n()) %>%
head(10)
uber.set %>%
group_by(Lat, Lon) %>%
summarise(n=n() ,.groups = 'drop') %>%
head(10)
uber.set %>%
group_by(Lat = round(Lat,3), Lon) %>%
summarise(n=n() ,.groups = 'drop') %>%
head(10)
uber.set %>%
group_by(Lat = round(Lat,3), Lon = roung(Lon,3)) %>%
summarise(n=n() ,.groups = 'drop') %>%
arrange(desc(n)) %>%
head(10)
uber.set %>%
group_by(Lat = round(Lat,3), Lon = round(Lon,3)) %>%
summarise(n=n() ,.groups = 'drop') %>%
arrange(desc(n)) %>%
head(10)
top100<- uber.set %>%
group_by(Lat = round(Lat,3), Lon = round(Lon,3)) %>%
summarise(n=n() ,.groups = 'drop') %>%
arrange(desc(n)) %>%
head(100)
mapview(top_spots, xcol = "Lon", ycol = "Lat", crs = 4269)
library(mapview)
mapview(top100, xcol = "Lon", ycol = "Lat", crs = 4269)
setwd("~/Documents/Handong/2024-2/Bioinformatics/RNAseq")
library(DESeq2)
library(org.Hs.eg.db)
library(clusterProfiler)
BiocManager::install("clusterProfiler")
library(clusterProfiler)
library(org.Hs.eg.db)
countData <- read.csv("gene_count_matrix.csv", row.names = 1)
colData <- data.frame(condition = factor(c("Normal","Cancer")),  row.names = colnames(countData))
countData <- read.csv("gene_count_matrix.csv", row.names = 1)
countData %>% head()
colnames(countData)
data.frame(condition = factor(c("Normal","Cancer"))
colData <- data.frame(condition = factor(c("Normal","Cancer")),  row.names = colnames(countData))
colData <- data.frame(condition = factor(c("Normal","Normal","Normal","Cancer", "Cancer", "Cancer")),  row.names = colnames(countData))
colData
dds <- DESeqDataSetFromMatrix( countData = countData, colData = colData, design = ~ condition )
dds
dds <- DESeq(dds)
deseq2_result <- result(dds)
deseq2_result <- results(dds)
deseq2_result
group <- factor(c("Normal", "Normal","Normal", "Cancer", "Cancer","Cancer"))
group
deseq2_result %>% head()
p_values <- apply(countData, 1, function(x) {
normal <- as.numeric(x[1:3]) #정상인 샘플 발현량
cancer <- as.numeric(x[4:6]) #암환자 샘플 발현량
t.test(normal, cancer)$p.value #t-test 수행 후 p-value 반환
})
p_values <- apply(countData, 1, function(x) {
normal <- as.numeric(x[1:3]) # 정상인 샘플 발현량
cancer <- as.numeric(x[4:6]) # 암환자 샘플 발현량
# Check if the values in either group are constant
if (var(normal) == 0 || var(cancer) == 0) {
return(NA) # Return NA if values are constant
} else {
return(t.test(normal, cancer)$p.value) # Perform t-test and return p-value
}
})
p_values
t_test_results <- data.frame( Gene = rownames(countData), P_Value = p_values )
significant_genes <- subset(t_test_results, P_Value < 0.05)
significant_genes
deseq2_genes <- deseq2_result$Gene[deseq2_result$padj < 0.05]
deseq2_genes
ttest_genes <- t_test_result$Gene[t_test_result$P_Value < 0.05]
ttest_genes <- t_test_result$Gene[t_test_results$P_Value < 0.05]
ttest_genes <- t_test_result$Gene[t_test_results$P_Value < 0.05]
ttest_genes <- t_test_results$Gene[t_test_results$P_Value < 0.05]
ttest_genes
common_genes <- intersect(deseq2_genes, ttest_genes)
common_genes
deseq2_only <- setdiff(deseq2_genes, ttest_genes)
ttest_only <- setdiff(ttest_genes, deseq2_genes)
ttest_only
deseq2_only
go_deseq2 <- enrichGO(
gene = deseq2_only,
OrgDb = org.Hs.eg.db,
keyType = "SYMBOL",
ont = "BP",
pvalueCutoff = 0.05)
go_deseq2
go_deseq2 <- enrichGO(
gene = ttest_only,
OrgDb = org.Hs.eg.db,
keyType = "SYMBOL",
ont = "BP",
pvalueCutoff = 0.05)
countData %>% head()
countData %>% is.na()
countData %>% is.na() %>% sum()
deseq2_result
keep <- rowSums(counts(dds)) > 1
dds <- dds[keep, ]
dds
summary(deseq2_result)
deseq2_filtered_result <- na.omit(deseq2_result)
deseq2_filtered_result
deseq2_result %>% head()
group <- factor(c("Normal", "Normal","Normal", "Cancer", "Cancer","Cancer"))
p_values <- apply(countData, 1, function(x) {
normal <- as.numeric(x[1:3]) # 정상인 샘플 발현량
cancer <- as.numeric(x[4:6]) # 암환자 샘플 발현량
# Check if the values in either group are constant
if (var(normal) == 0 || var(cancer) == 0) {
return(NA) # Return NA if values are constant
} else {
return(t.test(normal, cancer)$p.value) # Perform t-test and return p-value
}
})
t_test_results <- data.frame( Gene = rownames(countData), P_Value = p_values )
significant_genes <- subset(t_test_results, P_Value < 0.05)
significant_genes
deseq2_genes <- deseq2_filtered_result$Gene[deseq2_filtered_result$padj < 0.05]
deseq2_genes
# Remove rows where padj is NA, then filter genes with padj < 0.05
deseq2_genes <- deseq2_filtered_result$Gene[!is.na(deseq2_filtered_result$padj) & deseq2_filtered_result$padj < 0.05]
deseq2_genes
countData %>% head()
colData
dds %>% head()
countData %>% length()
countData
countData %>% nrow()
colData <- data.frame(condition = factor(c("Normal","Normal","Normal","Cancer", "Cancer", "Cancer")),  row.names = colnames(countData))
colData
DESeqDataSetFromMatrix
dds <- DESeqDataSetFromMatrix(countData = countData, colData = colData, design = ~ condition )
dds %>% head()
dds <- DESeqDataSetFromMatrix(countData = countData, colData = colData, design = ~ batch + condition )
dds <- DESeqDataSetFromMatrix(countData = countData, colData = colData, design = ~ condition )
dds <- DESeq(dds)
dds
resultsNames(dds)
deseq2_result <- results(dds, name="condition_Normal_vs_Cancer")
summary(deseq2_result)
deseq2_result
lfcShrink(dds, coef="condition_trt_vs_untrt", type="apeglm")
lfcShrink(dds, coef="condition_Normal_vs_Cancer", type="apeglm")
BiocManager::install("apeglm")
lfcShrink(dds, coef="condition_Normal_vs_Cancer", type="apeglm")
summary(deseq2_result)
deseq2_result <- deseq2_result[order(deseq2_result$padj),]
head(deseq2_result)
par(mfrow=c(2,3))
plotCounts(dds, gene="gene-LRRC71|LRRC71", intgroup="dex")
plotCounts(dds, gene="gene-LRRC71|LRRC71")
plotCounts(dds, gene="gene-NES|NES", intgroup="dex")
plotCounts(dds, gene="gene-NES|NES")
plotCounts(dds, gene="gene-LOC105379241|LOC105379241")
plotCounts(dds, gene="gene-EVA1A|EVA1A")
plotCounts(dds, gene="gene-EIF4A1|EIF4A1")
plotCounts(dds, gene="gene-GIMAP5|GIMAP5")
#reset par
par(mfrow=c(1,1))
# Make a basic volcano plot
with(deseq2_result, plot(log2FoldChange, -log10(pvalue), pch=20, main="Volcano plot", xlim=c(-3,3)))
# Add colored points: blue if padj<0.01, red if log2FC>1 and padj<0.05)
with(subset(deseq2_result, padj<.01 ), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
with(subset(deseq2_result, padj<.01 & abs(log2FoldChange)>2), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
vsdata <- vst(dds, blind=FALSE)
plotPCA(vsdata, intgroup="dex")
plotPCA(vsdata)
deseq2_result %>% head()
p_values <- apply(countData, 1, function(x) {
normal <- as.numeric(x[1:3]) # 정상인 샘플 발현량
cancer <- as.numeric(x[4:6]) # 암환자 샘플 발현량
# Check if the values in either group are constant
if (var(normal) == 0 || var(cancer) == 0) {
return(NA) # Return NA if values are constant
} else {
return(t.test(normal, cancer)$p.value) # Perform t-test and return p-value
}
})
p_values
t_test_results <- data.frame( Gene = rownames(countData), P_Value = p_values )
significant_genes <- subset(t_test_results, P_Value < 0.05)
significant_genes
plotDispEsts(dds)
resLFC <- lfcShrink(dds, coef="condition_Normal_vs_Cancer", type="apeglm")
resLFC
plotMA(resLFC, ylim=c(-2,2))
plotCounts(dds, gene=which.min(res$padj), intgroup="condition")
plotCounts(dds, gene=which.min(deseq2_result$padj), intgroup="condition")
e
select <- order(rowMeans(counts(dds,normalized=TRUE)),
decreasing=TRUE)[1:20]
deseq2_result %>% head()
top10_genes <- rownames(deseq2_result)[order(deseq2_result$padj, decreasing = FALSE)][1:10]
top10_genes
# Subset countData for top 10 genes and specific samples
top10_counts <- countData[top10_genes, c("sample1", "sample4")]
top10_counts
countData %>% head()
countData <- read.csv("gene_count_matrix.csv", row.names = 1)
countData %>% head()
BiocManager::install("biomaRt")
library(biomaRt)
########################### gene length ###########################
# Extract gene names before the '|' delimiter
gene_names <- sapply(strsplit(rownames(countData), split = "\\|"), `[`, 1)
# Connect to the Ensembl database
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")  # For human genes
# Query for gene lengths
gene_info <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol", "gene_length"),
filters = "hgnc_symbol",
values = gene_names,
mart = ensembl)
# Query for gene lengths
gene_info <- getBM(listAttributes = c("ensembl_gene_id", "hgnc_symbol", "gene_length"),
filters = "hgnc_symbol",
values = gene_names,
mart = ensembl)
# Use listAttributes(ensembl) to check available attributes
attributes <- listAttributes(ensembl)  # Optional, to check available attributes
# Query for start and end positions
gene_info <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol", "start_position", "end_position"),
filters = "hgnc_symbol",
values = gene_names,
mart = ensembl)
# Calculate gene lengths
gene_info$gene_length <- gene_info$end_position - gene_info$start_position
# Ensure gene lengths align with your dataset
head(gene_info)
gene_info
countData %>% head()
countData %>% head(10)
plotMA(resLFC, ylim=c(-2,2))
plotCounts(dds, gene=which.min(deseq2_result$padj), intgroup="condition")
deseq2_result
deseq2_result <- results(dds, name="condition_Normal_vs_Cancer")
deseq2_result
par(mfrow=c(2,3))
plotCounts(dds, gene="gene-LRRC71|LRRC71")
plotCounts(dds, gene="gene-NES|NES")
plotCounts(dds, gene="gene-LOC105379241|LOC105379241")
plotCounts(dds, gene="gene-EVA1A|EVA1A")
plotCounts(dds, gene="gene-EIF4A1|EIF4A1")
plotCounts(dds, gene="gene-GIMAP5|GIMAP5")
son.wiki.doc <-
"Son Heung-min is a South Korean professional footballer who plays as a forward for Premier League club Tottenham Hotspur and captains the South Korea national team. Considered one of the best forwards in the world and one of the greatest Asian footballers of all time, he is known for his explosive speed, finishing, two-footedness and ability to link play.
Born in Chuncheon, Gangwon Province, Son relocated to Germany to join Hamburger SV at 16, making his debut in the Bundesliga in 2010. In 2013, he moved to Bayer Leverkusen for a club record €10 million before signing for Tottenham for £22 million two years later, becoming the most expensive Asian player in history. While at Tottenham, Son became the top Asian goalscorer in both Premier League and Champions League history, and surpassed Cha Bum-kun's record for most goals scored by a Korean player in European competition. In 2019, he became the second Asian in history to reach and start a UEFA Champions League final after compatriot Park Jisung. In the 2021–22 season, he won, shared alongside Mohamed Salah, the Premier League Golden Boot award with 23 goals, becoming the first Asian player to win it."
son.para <- strsplit(son.wiki.doc, "\n")
son.para
son.para <- strsplit(son.wiki.doc, "\n") %>% unlist()
son.para
son.sent <- lapply(son.para, strsplit, "\\. ")
son.sent
son.sent <- lapply(son.para, strsplit, "\\. ") %>% unlist()
son.sent
son.sent <- lapply(son.para, strsplit, "\\. ")
son.sent
son.sent <- lapply(son.para[[1]], strsplit, "\\. ")
son.para <- strsplit(son.wiki.doc, "\n")
son.sent <- lapply(son.para[[1]], strsplit, "\\. ")
son.sent
son.para
son.sent <- lapply(son.para[[1]], strsplit, "\\. ")
son.sent
son.sent[[1]]
son.sent <- list()
for (i in (1:length(son.para))){
son.sent[[i]] <- strsplit(son.para[[i]], "\\. ")
}
son.sent
son.sent[[1]]
son.word <- list()
for (i in (1:length(son.sent[[1]]))){
son.word[[i]] <- strsplit(son.word[[i]], "\\. ")
}
son.sent[[1]]
son.word[[i]] <- strsplit(son.word[[i]], " ")
son.word[[i]] <- strsplit(son.sent[[i]], " ")
for (i in (1:length(son.sent[[1]]))){
son.word[[i]] <- strsplit(son.sent[[1]][[i]], " ")
}
son.word
son.word[[1]]
son.word %>% unlist()
son.word
son.word %>% unlist()
library(ngram)
son.word.ng <- son.wiki.doc %>% ngram(3)
son.word.ng
son.word.ng <- son.wiki.doc %>% ngram(3) %>% get.phrasetable()
son.word.ng
son.wiki.doc %>% ngram(3) %>% get.ngrams()
library(RWeka)
son.wiki.doc %>%
NGramTokenizer(
Weka_control(min=2, max=3)
)
son.wiki.doc %>%
NGramTokenizer(
Weka_control(min=2, max=3)
) %>% get.phrasetable()
